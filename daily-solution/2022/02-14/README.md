# 540. 有序数组中的单一元素
给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。
请你找出并返回只出现一次的那个数。
你设计的解决方案必须满足 `O(log n)` 时间复杂度和 `O(1)` 空间复杂度。

 

**示例 1:**

输入: nums = [1,1,2,3,3,4,4,8,8]
输出: 2

**示例 2:**

输入: nums =  [3,3,7,7,10,11,11]
输出: 10
 

提示:

- `1 <= nums.length <= 105`
- `0 <= nums[i] <= 105`

## 题解

### 最优题解
```python
```

### 我的题解
**思路:**
拿`奇数-1`(因为数组下标0起始)的和下一个进行比对,如果不相同则记录前一个.
此外,**注意边界值**:最后一个没有下一个用来比对了,因为数组数字的数量**必然为奇数**,因此`while`的条件就成了**提前在上一次奇数处停下**,如果此时此前一直都成对,那么最后一个必然是单身狗🐶.这样就可以防止边界值溢出.
```python
class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        n=0
        i=0
        result = nums[0]
        while n < len(nums) - 2:
            n = 2 * i + 1
            # 比对
            if nums[n-1] != nums[n]:
                result = nums[n-1]
                break
            i+=1
            result = nums[n+1]

        return result

```
